# SushiMaker bridge exploit

## Summary

- On several occasions in January, 2021, a vulnerability was exploited extracting more than `200 eth` from SushiSwap.
- A flaw in contract logic and missing bridge pairs allowed the `Sushi/xSushi` rewards for some liquidity pairs to be drained by an exploiter.

## Background

SushiSwap has a rewards system for liquidity providers called the [Sushibar](https://docs.sushi.com/products/yield-farming/the-sushibar), whereby 0.05% of the 0.3% LP reward fee is rewarded to `Sushi` stakers. A minimum of once per day the rewards contract is called and the 0.05%, in the form of LP tokens, is sold off for `Sushi`. 

Under certain conditions this call would revert and the rewards would not be sold, building up over time. Opportunists found a way to have these rewards sold into low liquidity pools and extract the rewards for themselves by taking advantage of high slippage. 

It is a simple exploit to undertake as no contract creation is required: the exploiter need only know which pairs are vulnerable and then to run certain transactions in the SushiSwap system.

## This repository

The repository is a Hardhat based re-construction of one example of the exploit where the attacker managed to extract roughly `64 eth`. To use it, clone the repository and then install the dependencies with `npm install`. Rename the `.env-sample` file to `.env` and paste in your [Alchemyapi](https://alchemyapi.io/) `url`. Running `npx hardhat test` will execute the transactions that the exploiter ran against a forked mainnet version as if you were the exploiter.

## Details of the vulnerability

LP token rewards from LP pools are periodically [deposited to SushiMaker](https://etherscan.io/address/0xe11fc0b43ab98eb91e9836129d1ee7c3bc95df50#tokentxns) where they are then sold to their underlying tokens for `Sushi` and rewarded to `Sushi/xSushi` stakers. 

This is done by calling [convert](https://github.com/sushiswap/sushiswap/blob/77ced18a2b8293d989ad7d61eeb7880e805f400f/contracts/SushiMaker.sol#L100) which itself calls [_convert](https://github.com/sushiswap/sushiswap/blob/77ced18a2b8293d989ad7d61eeb7880e805f400f/contracts/SushiMaker.sol#L120). This method validates that the pair exists and then transfers the LP tokens back to their pool in exchange for the underlying tokens; the LP tokens are burned, the `LogConvert` event is emitted and [this calls](https://github.com/sushiswap/sushiswap/blob/77ced18a2b8293d989ad7d61eeb7880e805f400f/contracts/SushiMaker.sol#L142) [_convertStep](https://github.com/sushiswap/sushiswap/blob/77ced18a2b8293d989ad7d61eeb7880e805f400f/contracts/SushiMaker.sol#L149) for the corresponding two tokens and the respective amounts.

`_convertStep` handles a series of cases depending on the token pair. Simplifying the code somewhat, it breaks down to this:

```solidity
	if (token0 == token1) {
            // do something
        } else if (token0 == sushi) {
            // do something
        } else if (token1 == sushi) {
            // do something
        } else if (token0 == weth) {
            // do something
        } else if (token1 == weth) {
            // do something
        } else {
            // eg. MIC - USDT
            address bridge0 = bridgeFor(token0);
            address bridge1 = bridgeFor(token1);
            if (bridge0 == token1) {
                // do something
            } else if (bridge1 == token0) {
                // do something
            } else {
                sushiOut = _convertStep(
                    bridge0,
                    bridge1, // eg. USDT - DSD - and bridgeFor(DSD) = WBTC
                    _swap(token0, bridge0, amount0, address(this)),
                    _swap(token1, bridge1, amount1, address(this))
                );
            }
        }
    }
```

The vulnerability arises when dealing with non-`weth`, non-`sushi` pairs such that the code that executes is contained in that final `else` block above. First [bridgeFor](https://github.com/sushiswap/sushiswap/blob/77ced18a2b8293d989ad7d61eeb7880e805f400f/contracts/SushiMaker.sol#L64) is called to find a bridge for both tokens in the `mapping(address => address) internal _bridges;` mapping and if it doesn't find any value, it returns `weth` as seen below:

```solidity
function bridgeFor(address token) public view returns (address bridge) {
        bridge = _bridges[token];
        if (bridge == address(0)) {
            bridge = weth;
        }
    }
```

Moving past the calls to `bridgeFor`, the first two conditions are not met as both of the bridge tokens return as `weth` and neither `token0` nor `token1` are `weth` (if they were then the code would have matched one of the previous `weth` cases in the blocks above). Now in this final `else` block `_convertStep` is called anew, with two `_swap` calls to determine the last two parameters for `_convertStep`. Using `digg/wbtc` as an example would look like this:

```solidity
_swap(digg, weth, amount0, address(this)),
_swap(wbtc, weth, amount1, address(this))
```

And here is where the opportunity arises, because [_swap](https://github.com/sushiswap/sushiswap/blob/77ced18a2b8293d989ad7d61eeb7880e805f400f/contracts/SushiMaker.sol#L222) first tries to find a matching pair and if it doesn't, it reverts:

```solidity
function _swap(
        address fromToken,
        address toToken,
        uint256 amountIn,
        address to
    ) internal returns (uint256 amountOut) {
        // Checks
        // X1 - X5: OK
        IUniswapV2Pair pair =
            IUniswapV2Pair(factory.getPair(fromToken, toToken));
        require(address(pair) != address(0), "SushiMaker: Cannot convert");
```

So what does this mean? This means that anytime someone tried to call `convert` on the `digg/wbtc` pool the transaction would revert and the rewards would stay in the SushiMaker contract and build up over time. So therein lies the opportunity.

## Details of the exploit

**How could someone take advantage of this growing pile of rewards?**

The answer lies somehow with that failing `_swap`. Remember that `_swap` is trying to find a `digg/weth` and `wbtc/weth` pool to cash out. And this is what the exploiter did: they *created* a `digg/weth` pool, and by doing so the rewards could then be sold into that pool. Furthermore, they created the pool with very low liquidity such that when the accumulated `digg` was sold into the pool the slippage meant that a lot of `digg` was added to the pool in return for a very small amount of `weth`. And then they simply reversed that by selling a very small amount of `weth` into the pool for a very large amount of `digg`. Let's look at the math of how that worked.

### Slippage, K, and all your `digg` are belong to us

The key here was to create the `digg/weth` pool and to do so with low liquidity. This is what the exploiter did in [this transaction](https://etherscan.io/tx/0xa815480589250d649314731d084fb4f58137b5fef70c8b19dc3cadc2ccc0b21f), adding a measly `0.000017211` `digg` and `0.001` `weth`. Why so little?

If you are not familiar with constant product AMMs [this article that coined the term *impermanent loss*](https://pintail.medium.com/uniswap-a-good-deal-for-liquidity-providers-104c0b6816f2) is a good read. Suffice to say, a `constant K` is determined when a pool is created by multiplying together the amounts of the two tokens deposited as initial liquidity:

```
k = amountX * amountY
  = (amount of digg) * (amount of eth)
  = 0.000017211 * 0.001
  = 0.000000017211
```

Here is what happens to the pool if a large amount of `digg` is sold into it from the `wbtc/digg` LP rewards (actual numbers from [this transaction](https://etherscan.io/tx/0x747088ed3054d66fbd2c2ec6f6e0b077e71c3155dab0d56ccea2b5841903738f)):

```
digg to sell = 1.140602218 (<- digg sold into pool)
digg in pool = 0.00017211
digg total   = 1.140774328 (<- the new balance of digg in the pool)

weth required in the pool to keep K constant:
= 0.000000017211/1.140774328 (k / amount of digg)
= 0.00000000150871207

weth in the pool = 0.001
weth to remain   = 0.00000000150871207
weth sold in tx  = 0.00099999849 (<- weth the digg seller receives)
```

The successful `convert` call dumped `1.14 digg` (worth close to `2.8 wbtc` at the time) into the thin `weth/digg` pool and received `0.00099999849` `weth` rewards to send to `Sushi/xSushi` stakers. And what did the exploiter then do? They *sold* `0.001 weth` into the pool and extracted the `1.14 digg` which they [then sold for over `64 eth`](https://etherscan.io/tx/0xba833487c09f934c7ed77ad415ff4f322d470a1fa508120aacea8a8f0bb656a9). Here is the math for extracting the `digg`:

```
weth to sell   = 0.001 (<- weth sold into pool)
weth in pool   = 0.00000000150871207
weth total     = 0.00100000150871207

digg required in the pool to keep k constant:
= 0.000000017211/0.00100000150871207 (k / amount of weth)
= 0.00001721097

digg in the pool = 1.140774328
digg to remain   = 0.00001721097
digg sold in tx  = 1.14075711703 (<- digg the weth seller receives)
```

## Timeline of events

This isn't a complete list of every time this vulnerability was exploited, but it does encompass several examples.

### DIGG

- [Jan-24-2021 07:04:57 PM +UTC,](https://etherscan.io/tx/0xa815480589250d649314731d084fb4f58137b5fef70c8b19dc3cadc2ccc0b21f) create `digg/eth` lp pool.
- [Jan-24-2021 07:07:41 PM +UTC](https://etherscan.io/tx/0x747088ed3054d66fbd2c2ec6f6e0b077e71c3155dab0d56ccea2b5841903738f), convert call.
- [Jan-24-2021 07:07:41 PM +UTC](https://etherscan.io/tx/0xba833487c09f934c7ed77ad415ff4f322d470a1fa508120aacea8a8f0bb656a9), swap `0.001 eth` for `64.649 eth`.
- [Jan-24-2021 09:52:58 PM +UTC](https://etherscan.io/tx/0x09450b78ecc1e588e5545fc1769a8180f78ec999bec77ce1c00d792783e114b0), convert call.
- [Jan-24-2021 09:52:58 PM +UTC](https://etherscan.io/tx/0x0eff5e177dfe6857a7e933304d4f9236f145a69c8116f651f5d5457791e9b95a), swap `0.001 eth` for `63.65 eth`.
- [Jan-25-2021 07:37:01 PM +UTC](https://etherscan.io/tx/0xd9fc665489e3b4bed1e31d2ecb318819d05b3e8136af872929378fb73252ff3d), convert call.
- [Jan-25-2021 07:37:01 PM +UTC](https://etherscan.io/tx/0x65f4145f6c519be266ac2029b532b72deb1fef037e5947077cbcda76a74a3090), swap `0.001 eth` for `1.08 eth`.
- [Jan-25-2021 08:07:35 PM +UTC](https://etherscan.io/tx/0x90fb0c9976361f537330a5617a404045ffb3fef5972cf67b531386014eeae7a9), convert call.
- [Jan-25-2021 08:07:35 PM +UTC](https://etherscan.io/tx/0x0af5a6d2d8b49f68dcfd4599a0e767450e76e08a5aeba9b3d534a604d308e60b), swap `0.001 eth` fro `81.6846 eth`.

### PHOON

- [Jan-21-2021 12:57:40 PM +UTC](https://etherscan.io/tx/0x80d01a780952df6c2ab4943c403345642f4aff584ce38d61f380a38bc5fa495e), create `phoon/eth` lp pool, note that this is not the same wallet that called the next two transactions.
- [Jan-24-2021 06:48:20 PM +UTC](https://etherscan.io/tx/0x994b9616c0382d59056181a6367b96ee584b8a75523ca3166e74c1365081c055), convert call.
- [Jan-24-2021 06:48:20 PM +UTC](https://etherscan.io/tx/0x7b0798e1cf2ba57e221541e98479e50cc3a5b719c0e72247293c9d91b4eb261c), swap `0.001 eth` for `3.12 eth`.

### MIC

- [Jan-07-2021 03:19:25 PM +UTC](https://etherscan.io/tx/0x12215bb1150e51b63d0c7fa4829f7501ec41dcf43065c0ed2df93090d348b241), convert call on `mic/usdt` pair.
- [Jan-07-2021 03:19:25 PM +UTC](https://etherscan.io/tx/0xa4d77b3c2b34bd82b755541631c8886d8f32db511a80c530b87289a9f44a5311), swap `0.05 weth` for `0.32 weth`.

### DSD

- [Dec-26-2020 02:07:10 PM +UTC](https://etherscan.io/tx/0xfc9442414e85dc329247e3bba5a7872ee279c35c9f5e8e5bb156183730a6dbc7), create `dsd/eth` lp pool, note that this is not the same wallet that called the next two transactions.
- [Jan-06-2021 04:12:43 PM +UTC](https://etherscan.io/tx/0xad27a636a86f6a3867cafec652b8ad005f3e290c4117e77cd2c040bb78f63d97), convert call on `dsd/usdc` pair.
- [Jan-06-2021 04:12:43 PM +UTC](https://etherscan.io/tx/0x4dcc3eb2710379f0f7877b9f65905f1fc9a427704771a766f8ecdf13c9040c11), swap `0.0001 eth` for `0.187 eth`.
